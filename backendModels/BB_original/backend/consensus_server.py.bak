# consensus_server.py
# Servidor de consenso para el proyecto Capibara6

from flask import Flask, request, jsonify
import requests
import json
import logging
from models_config import MODEL_CONFIGS, TIMEOUT

app = Flask(__name__)

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@app.route('/api/consensus/query', methods=['POST'])
def consensus_query():
    try:
        data = request.get_json()
        user_prompt = data.get('prompt', '')
        
        # Recopilar respuestas de múltiples modelos
        responses = {}
        errors = {}
        
        for model_name, config in MODEL_CONFIGS.items():
            try:
                response = requests.post(
                    config['endpoint'],
                    json={'prompt': user_prompt, **data},
                    timeout=TIMEOUT/1000  # Convertir de ms a segundos
                )
                
                if response.status_code == 200:
                    responses[model_name] = response.json()
                else:
                    errors[model_name] = f"Status {response.status_code}: {response.text}"
            except Exception as e:
                errors[model_name] = str(e)
                logger.error(f"Error al consultar modelo {model_name}: {e}")
        
        # Aplicar lógica de consenso (simplificada)
        result = {
            'status': 'success',
            'responses': responses,
            'errors': errors,
            'consensus_applied': True,
            'primary_choice': get_primary_choice(responses)
        }
        
        return jsonify(result)
    except Exception as e:
        logger.error(f"Error en servidor de consenso: {e}")
        return jsonify({'error': 'Error en el servidor de consenso'}), 500

def get_primary_choice(responses):
    """Lógica simple para determinar la mejor respuesta"""
    if not responses:
        return None
    
    # Para simplificar, retornamos la primera respuesta exitosa
    # En una implementación real, se aplicarían criterios más sofisticados
    for model_name, response in responses.items():
        if 'response' in response or 'content' in response:
            return {'model': model_name, 'response': response}
    
    return None

@app.route('/health', methods=['GET'])
def health_check():
    return jsonify({
        'status': 'healthy',
        'service': 'consensus_server',
        'models_available': list(MODEL_CONFIGS.keys())
    })

if __name__ == '__main__':
    import os
    port = int(os.environ.get('PORT', 5003))  # Cambiado de 5002 a 5003 para evitar conflicto
    app.run(host='0.0.0.0', port=port, debug=False)